// Code generated by BobGen psql v0.21.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
)

// Match is an object representing the database table.
type Match struct {
	ID           string                      `db:"id,pk" `
	Name         string                      `db:"name" `
	Slug         string                      `db:"slug" `
	Date         string                      `db:"date" `
	Timestamp    int64                       `db:"timestamp" `
	HomeRedCards int                         `db:"home_red_cards" `
	AwayRedCards int                         `db:"away_red_cards" `
	HomeID       string                      `db:"home_id" `
	AwayID       string                      `db:"away_id" `
	TournamentID string                      `db:"tournament_id" `
	Scores       types.JSON[json.RawMessage] `db:"scores" `
	WinCode      null.Val[int]               `db:"win_code" `
	MatchStatus  MatchStatus                 `db:"match_status" `
	SportType    null.Val[string]            `db:"sport_type" `
	HasLineup    null.Val[bool]              `db:"has_lineup" `
	HasTracker   null.Val[bool]              `db:"has_tracker" `
	IsFeatured   null.Val[bool]              `db:"is_featured" `
	ThumbnailURL null.Val[string]            `db:"thumbnail_url" `
	IsLive       null.Val[bool]              `db:"is_live" `
	LiveTracker  null.Val[string]            `db:"live_tracker" `
	CreatedAt    time.Time                   `db:"created_at" `
	UpdatedAt    time.Time                   `db:"updated_at" `

	R matchR `db:"-" `
}

// MatchSlice is an alias for a slice of pointers to Match.
// This should almost always be used instead of []*Match.
type MatchSlice []*Match

// MatchsTable contains methods to work with the matchs table
var MatchsTable = psql.NewTablex[*Match, MatchSlice, *MatchSetter]("", "matchs")

// MatchsQuery is a query on the matchs table
type MatchsQuery = *psql.TableQuery[*Match, MatchSlice, *MatchSetter]

// MatchsStmt is a prepared statment on matchs
type MatchsStmt = bob.QueryStmt[*Match, MatchSlice]

// matchR is where relationships are stored.
type matchR struct {
	AwayTeam   *Team       // matchs.matchs_away_id_fkey
	HomeTeam   *Team       // matchs.matchs_home_id_fkey
	Tournament *Tournament // matchs.matchs_tournament_id_fkey
}

// MatchSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type MatchSetter struct {
	ID           omit.Val[string]                      `db:"id,pk"`
	Name         omit.Val[string]                      `db:"name"`
	Slug         omit.Val[string]                      `db:"slug"`
	Date         omit.Val[string]                      `db:"date"`
	Timestamp    omit.Val[int64]                       `db:"timestamp"`
	HomeRedCards omit.Val[int]                         `db:"home_red_cards"`
	AwayRedCards omit.Val[int]                         `db:"away_red_cards"`
	HomeID       omit.Val[string]                      `db:"home_id"`
	AwayID       omit.Val[string]                      `db:"away_id"`
	TournamentID omit.Val[string]                      `db:"tournament_id"`
	Scores       omit.Val[types.JSON[json.RawMessage]] `db:"scores"`
	WinCode      omitnull.Val[int]                     `db:"win_code"`
	MatchStatus  omit.Val[MatchStatus]                 `db:"match_status"`
	SportType    omitnull.Val[string]                  `db:"sport_type"`
	HasLineup    omitnull.Val[bool]                    `db:"has_lineup"`
	HasTracker   omitnull.Val[bool]                    `db:"has_tracker"`
	IsFeatured   omitnull.Val[bool]                    `db:"is_featured"`
	ThumbnailURL omitnull.Val[string]                  `db:"thumbnail_url"`
	IsLive       omitnull.Val[bool]                    `db:"is_live"`
	LiveTracker  omitnull.Val[string]                  `db:"live_tracker"`
	CreatedAt    omit.Val[time.Time]                   `db:"created_at"`
	UpdatedAt    omit.Val[time.Time]                   `db:"updated_at"`
}

type matchColumnNames struct {
	ID           string
	Name         string
	Slug         string
	Date         string
	Timestamp    string
	HomeRedCards string
	AwayRedCards string
	HomeID       string
	AwayID       string
	TournamentID string
	Scores       string
	WinCode      string
	MatchStatus  string
	SportType    string
	HasLineup    string
	HasTracker   string
	IsFeatured   string
	ThumbnailURL string
	IsLive       string
	LiveTracker  string
	CreatedAt    string
	UpdatedAt    string
}

type matchRelationshipJoins[Q dialect.Joinable] struct {
	AwayTeam   bob.Mod[Q]
	HomeTeam   bob.Mod[Q]
	Tournament bob.Mod[Q]
}

func buildmatchRelationshipJoins[Q dialect.Joinable](ctx context.Context, typ string) matchRelationshipJoins[Q] {
	return matchRelationshipJoins[Q]{
		AwayTeam:   matchsJoinAwayTeam[Q](ctx, typ),
		HomeTeam:   matchsJoinHomeTeam[Q](ctx, typ),
		Tournament: matchsJoinTournament[Q](ctx, typ),
	}
}

func matchsJoin[Q dialect.Joinable](ctx context.Context) joinSet[matchRelationshipJoins[Q]] {
	return joinSet[matchRelationshipJoins[Q]]{
		InnerJoin: buildmatchRelationshipJoins[Q](ctx, clause.InnerJoin),
		LeftJoin:  buildmatchRelationshipJoins[Q](ctx, clause.LeftJoin),
		RightJoin: buildmatchRelationshipJoins[Q](ctx, clause.RightJoin),
	}
}

var MatchColumns = struct {
	ID           psql.Expression
	Name         psql.Expression
	Slug         psql.Expression
	Date         psql.Expression
	Timestamp    psql.Expression
	HomeRedCards psql.Expression
	AwayRedCards psql.Expression
	HomeID       psql.Expression
	AwayID       psql.Expression
	TournamentID psql.Expression
	Scores       psql.Expression
	WinCode      psql.Expression
	MatchStatus  psql.Expression
	SportType    psql.Expression
	HasLineup    psql.Expression
	HasTracker   psql.Expression
	IsFeatured   psql.Expression
	ThumbnailURL psql.Expression
	IsLive       psql.Expression
	LiveTracker  psql.Expression
	CreatedAt    psql.Expression
	UpdatedAt    psql.Expression
}{
	ID:           psql.Quote("matchs", "id"),
	Name:         psql.Quote("matchs", "name"),
	Slug:         psql.Quote("matchs", "slug"),
	Date:         psql.Quote("matchs", "date"),
	Timestamp:    psql.Quote("matchs", "timestamp"),
	HomeRedCards: psql.Quote("matchs", "home_red_cards"),
	AwayRedCards: psql.Quote("matchs", "away_red_cards"),
	HomeID:       psql.Quote("matchs", "home_id"),
	AwayID:       psql.Quote("matchs", "away_id"),
	TournamentID: psql.Quote("matchs", "tournament_id"),
	Scores:       psql.Quote("matchs", "scores"),
	WinCode:      psql.Quote("matchs", "win_code"),
	MatchStatus:  psql.Quote("matchs", "match_status"),
	SportType:    psql.Quote("matchs", "sport_type"),
	HasLineup:    psql.Quote("matchs", "has_lineup"),
	HasTracker:   psql.Quote("matchs", "has_tracker"),
	IsFeatured:   psql.Quote("matchs", "is_featured"),
	ThumbnailURL: psql.Quote("matchs", "thumbnail_url"),
	IsLive:       psql.Quote("matchs", "is_live"),
	LiveTracker:  psql.Quote("matchs", "live_tracker"),
	CreatedAt:    psql.Quote("matchs", "created_at"),
	UpdatedAt:    psql.Quote("matchs", "updated_at"),
}

type matchWhere[Q psql.Filterable] struct {
	ID           psql.WhereMod[Q, string]
	Name         psql.WhereMod[Q, string]
	Slug         psql.WhereMod[Q, string]
	Date         psql.WhereMod[Q, string]
	Timestamp    psql.WhereMod[Q, int64]
	HomeRedCards psql.WhereMod[Q, int]
	AwayRedCards psql.WhereMod[Q, int]
	HomeID       psql.WhereMod[Q, string]
	AwayID       psql.WhereMod[Q, string]
	TournamentID psql.WhereMod[Q, string]
	Scores       psql.WhereMod[Q, types.JSON[json.RawMessage]]
	WinCode      psql.WhereNullMod[Q, int]
	MatchStatus  psql.WhereMod[Q, MatchStatus]
	SportType    psql.WhereNullMod[Q, string]
	HasLineup    psql.WhereNullMod[Q, bool]
	HasTracker   psql.WhereNullMod[Q, bool]
	IsFeatured   psql.WhereNullMod[Q, bool]
	ThumbnailURL psql.WhereNullMod[Q, string]
	IsLive       psql.WhereNullMod[Q, bool]
	LiveTracker  psql.WhereNullMod[Q, string]
	CreatedAt    psql.WhereMod[Q, time.Time]
	UpdatedAt    psql.WhereMod[Q, time.Time]
}

func MatchWhere[Q psql.Filterable]() matchWhere[Q] {
	return matchWhere[Q]{
		ID:           psql.Where[Q, string](MatchColumns.ID),
		Name:         psql.Where[Q, string](MatchColumns.Name),
		Slug:         psql.Where[Q, string](MatchColumns.Slug),
		Date:         psql.Where[Q, string](MatchColumns.Date),
		Timestamp:    psql.Where[Q, int64](MatchColumns.Timestamp),
		HomeRedCards: psql.Where[Q, int](MatchColumns.HomeRedCards),
		AwayRedCards: psql.Where[Q, int](MatchColumns.AwayRedCards),
		HomeID:       psql.Where[Q, string](MatchColumns.HomeID),
		AwayID:       psql.Where[Q, string](MatchColumns.AwayID),
		TournamentID: psql.Where[Q, string](MatchColumns.TournamentID),
		Scores:       psql.Where[Q, types.JSON[json.RawMessage]](MatchColumns.Scores),
		WinCode:      psql.WhereNull[Q, int](MatchColumns.WinCode),
		MatchStatus:  psql.Where[Q, MatchStatus](MatchColumns.MatchStatus),
		SportType:    psql.WhereNull[Q, string](MatchColumns.SportType),
		HasLineup:    psql.WhereNull[Q, bool](MatchColumns.HasLineup),
		HasTracker:   psql.WhereNull[Q, bool](MatchColumns.HasTracker),
		IsFeatured:   psql.WhereNull[Q, bool](MatchColumns.IsFeatured),
		ThumbnailURL: psql.WhereNull[Q, string](MatchColumns.ThumbnailURL),
		IsLive:       psql.WhereNull[Q, bool](MatchColumns.IsLive),
		LiveTracker:  psql.WhereNull[Q, string](MatchColumns.LiveTracker),
		CreatedAt:    psql.Where[Q, time.Time](MatchColumns.CreatedAt),
		UpdatedAt:    psql.Where[Q, time.Time](MatchColumns.UpdatedAt),
	}
}

// Matchs begins a query on matchs
func Matchs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MatchsQuery {
	return MatchsTable.Query(ctx, exec, mods...)
}

// FindMatch retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindMatch(ctx context.Context, exec bob.Executor, IDPK string, cols ...string) (*Match, error) {
	if len(cols) == 0 {
		return MatchsTable.Query(
			ctx, exec,
			SelectWhere.Matchs.ID.EQ(IDPK),
		).One()
	}

	return MatchsTable.Query(
		ctx, exec,
		SelectWhere.Matchs.ID.EQ(IDPK),
		sm.Columns(MatchsTable.Columns().Only(cols...)),
	).One()
}

// MatchExists checks the presence of a single record by primary key
func MatchExists(ctx context.Context, exec bob.Executor, IDPK string) (bool, error) {
	return MatchsTable.Query(
		ctx, exec,
		SelectWhere.Matchs.ID.EQ(IDPK),
	).Exists()
}

// Update uses an executor to update the Match
func (o *Match) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := MatchsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single Match record with an executor
func (o *Match) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return MatchsTable.Delete(ctx, exec, o)
}

// Reload refreshes the Match using the executor
func (o *Match) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := MatchsTable.Query(
		ctx, exec,
		SelectWhere.Matchs.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o MatchSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return MatchsTable.DeleteMany(ctx, exec, o...)
}

func (o MatchSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals MatchSetter) (int64, error) {
	rowsAff, err := MatchsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o MatchSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]string, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.Matchs.ID.In(IDPK...),
	)

	o2, err := Matchs(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func matchsJoinAwayTeam[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, TeamsTable.Name(ctx)).On(
			TeamColumns.ID.EQ(MatchColumns.AwayID),
		),
	}
}
func matchsJoinHomeTeam[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, TeamsTable.Name(ctx)).On(
			TeamColumns.ID.EQ(MatchColumns.HomeID),
		),
	}
}
func matchsJoinTournament[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, TournamentsTable.Name(ctx)).On(
			TournamentColumns.ID.EQ(MatchColumns.TournamentID),
		),
	}
}

// AwayTeam starts a query for related objects on teams
func (o *Match) AwayTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	return Teams(ctx, exec, append(mods,
		sm.Where(TeamColumns.ID.EQ(psql.Arg(o.AwayID))),
	)...)
}

func (os MatchSlice) AwayTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	PKArgs := make([]bob.Expression, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.AwayID))
	}

	return Teams(ctx, exec, append(mods,
		sm.Where(psql.Group(TeamColumns.ID).In(PKArgs...)),
	)...)
}

// HomeTeam starts a query for related objects on teams
func (o *Match) HomeTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	return Teams(ctx, exec, append(mods,
		sm.Where(TeamColumns.ID.EQ(psql.Arg(o.HomeID))),
	)...)
}

func (os MatchSlice) HomeTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	PKArgs := make([]bob.Expression, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.HomeID))
	}

	return Teams(ctx, exec, append(mods,
		sm.Where(psql.Group(TeamColumns.ID).In(PKArgs...)),
	)...)
}

// Tournament starts a query for related objects on tournaments
func (o *Match) Tournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TournamentsQuery {
	return Tournaments(ctx, exec, append(mods,
		sm.Where(TournamentColumns.ID.EQ(psql.Arg(o.TournamentID))),
	)...)
}

func (os MatchSlice) Tournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TournamentsQuery {
	PKArgs := make([]bob.Expression, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, psql.ArgGroup(o.TournamentID))
	}

	return Tournaments(ctx, exec, append(mods,
		sm.Where(psql.Group(TournamentColumns.ID).In(PKArgs...)),
	)...)
}

func (o *Match) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "AwayTeam":
		rel, ok := retrieved.(*Team)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.AwayTeam = rel

		if rel != nil {
			rel.R.AwayMatchs = MatchSlice{o}
		}
		return nil
	case "HomeTeam":
		rel, ok := retrieved.(*Team)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.HomeTeam = rel

		if rel != nil {
			rel.R.HomeMatchs = MatchSlice{o}
		}
		return nil
	case "Tournament":
		rel, ok := retrieved.(*Tournament)
		if !ok {
			return fmt.Errorf("match cannot load %T as %q", retrieved, name)
		}

		o.R.Tournament = rel

		if rel != nil {
			rel.R.Matchs = MatchSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("match has no relationship %q", name)
	}
}

func PreloadMatchAwayTeam(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Team, TeamSlice](orm.Relationship{
		Name: "AwayTeam",
		Sides: []orm.RelSide{
			{
				From: "matchs",
				To:   TableNames.Teams,
				ToExpr: func(ctx context.Context) bob.Expression {
					return TeamsTable.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matchs.AwayID,
				},
				ToColumns: []string{
					ColumnNames.Teams.ID,
				},
			},
		},
	}, TeamsTable.Columns().Names(), opts...)
}

func ThenLoadMatchAwayTeam(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchAwayTeam(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchAwayTeam", retrieved)
		}

		err := loader.LoadMatchAwayTeam(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchAwayTeam loads the match's AwayTeam into the .R struct
func (o *Match) LoadMatchAwayTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AwayTeam = nil

	related, err := o.AwayTeam(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.AwayMatchs = MatchSlice{o}

	o.R.AwayTeam = related
	return nil
}

// LoadMatchAwayTeam loads the match's AwayTeam into the .R struct
func (os MatchSlice) LoadMatchAwayTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	teams, err := os.AwayTeam(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range teams {
			if o.AwayID != rel.ID {
				continue
			}

			rel.R.AwayMatchs = append(rel.R.AwayMatchs, o)

			o.R.AwayTeam = rel
			break
		}
	}

	return nil
}

func PreloadMatchHomeTeam(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Team, TeamSlice](orm.Relationship{
		Name: "HomeTeam",
		Sides: []orm.RelSide{
			{
				From: "matchs",
				To:   TableNames.Teams,
				ToExpr: func(ctx context.Context) bob.Expression {
					return TeamsTable.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matchs.HomeID,
				},
				ToColumns: []string{
					ColumnNames.Teams.ID,
				},
			},
		},
	}, TeamsTable.Columns().Names(), opts...)
}

func ThenLoadMatchHomeTeam(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchHomeTeam(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchHomeTeam", retrieved)
		}

		err := loader.LoadMatchHomeTeam(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchHomeTeam loads the match's HomeTeam into the .R struct
func (o *Match) LoadMatchHomeTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HomeTeam = nil

	related, err := o.HomeTeam(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.HomeMatchs = MatchSlice{o}

	o.R.HomeTeam = related
	return nil
}

// LoadMatchHomeTeam loads the match's HomeTeam into the .R struct
func (os MatchSlice) LoadMatchHomeTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	teams, err := os.HomeTeam(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range teams {
			if o.HomeID != rel.ID {
				continue
			}

			rel.R.HomeMatchs = append(rel.R.HomeMatchs, o)

			o.R.HomeTeam = rel
			break
		}
	}

	return nil
}

func PreloadMatchTournament(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Tournament, TournamentSlice](orm.Relationship{
		Name: "Tournament",
		Sides: []orm.RelSide{
			{
				From: "matchs",
				To:   TableNames.Tournaments,
				ToExpr: func(ctx context.Context) bob.Expression {
					return TournamentsTable.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Matchs.TournamentID,
				},
				ToColumns: []string{
					ColumnNames.Tournaments.ID,
				},
			},
		},
	}, TournamentsTable.Columns().Names(), opts...)
}

func ThenLoadMatchTournament(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadMatchTournament(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load MatchTournament", retrieved)
		}

		err := loader.LoadMatchTournament(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadMatchTournament loads the match's Tournament into the .R struct
func (o *Match) LoadMatchTournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Tournament = nil

	related, err := o.Tournament(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.Matchs = MatchSlice{o}

	o.R.Tournament = related
	return nil
}

// LoadMatchTournament loads the match's Tournament into the .R struct
func (os MatchSlice) LoadMatchTournament(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tournaments, err := os.Tournament(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range tournaments {
			if o.TournamentID != rel.ID {
				continue
			}

			rel.R.Matchs = append(rel.R.Matchs, o)

			o.R.Tournament = rel
			break
		}
	}

	return nil
}

func (o *Match) InsertAwayTeam(ctx context.Context, exec bob.Executor, related *TeamSetter) error {
	rel, err := TeamsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.AwayTeam = rel

	o.AwayID = rel.ID

	o.R.AwayTeam.R.AwayMatchs = MatchSlice{o}

	return nil
}

func (o *Match) AttachAwayTeam(ctx context.Context, exec bob.Executor, rel *Team) error {
	var err error

	o.AwayID = rel.ID

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.AwayTeam = rel

	rel.R.AwayMatchs = append(rel.R.AwayMatchs, o)

	return nil
}

func (o *Match) InsertHomeTeam(ctx context.Context, exec bob.Executor, related *TeamSetter) error {
	rel, err := TeamsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.HomeTeam = rel

	o.HomeID = rel.ID

	o.R.HomeTeam.R.HomeMatchs = MatchSlice{o}

	return nil
}

func (o *Match) AttachHomeTeam(ctx context.Context, exec bob.Executor, rel *Team) error {
	var err error

	o.HomeID = rel.ID

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.HomeTeam = rel

	rel.R.HomeMatchs = append(rel.R.HomeMatchs, o)

	return nil
}

func (o *Match) InsertTournament(ctx context.Context, exec bob.Executor, related *TournamentSetter) error {
	rel, err := TournamentsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Tournament = rel

	o.TournamentID = rel.ID

	o.R.Tournament.R.Matchs = MatchSlice{o}

	return nil
}

func (o *Match) AttachTournament(ctx context.Context, exec bob.Executor, rel *Tournament) error {
	var err error

	o.TournamentID = rel.ID

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Tournament = rel

	rel.R.Matchs = append(rel.R.Matchs, o)

	return nil
}
