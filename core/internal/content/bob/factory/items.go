// Code generated by BobGen psql v0.21.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"encoding/json"
	"time"

	models "core/internal/content/bob"
	"github.com/aarondl/opt/omit"
	"github.com/jaswdr/faker"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/types"
)

type ItemMod interface {
	Apply(*ItemTemplate)
}

type ItemModFunc func(*ItemTemplate)

func (f ItemModFunc) Apply(n *ItemTemplate) {
	f(n)
}

type ItemModSlice []ItemMod

func (mods ItemModSlice) Apply(n *ItemTemplate) {
	for _, f := range mods {
		f.Apply(n)
	}
}

// ItemTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type ItemTemplate struct {
	ItemID     func() string
	IsHidden   func() bool
	Categories func() types.JSON[json.RawMessage]
	TimeStamp  func() time.Time
	Labels     func() types.JSON[json.RawMessage]
	Comment    func() string

	f *factory
}

// Apply mods to the ItemTemplate
func (o *ItemTemplate) Apply(mods ...ItemMod) {
	for _, mod := range mods {
		mod.Apply(o)
	}
}

// toModel returns an *models.Item
// this does nothing with the relationship templates
func (o ItemTemplate) toModel() *models.Item {
	m := &models.Item{}

	if o.ItemID != nil {
		m.ItemID = o.ItemID()
	}
	if o.IsHidden != nil {
		m.IsHidden = o.IsHidden()
	}
	if o.Categories != nil {
		m.Categories = o.Categories()
	}
	if o.TimeStamp != nil {
		m.TimeStamp = o.TimeStamp()
	}
	if o.Labels != nil {
		m.Labels = o.Labels()
	}
	if o.Comment != nil {
		m.Comment = o.Comment()
	}

	return m
}

// toModels returns an models.ItemSlice
// this does nothing with the relationship templates
func (o ItemTemplate) toModels(number int) models.ItemSlice {
	m := make(models.ItemSlice, number)

	for i := range m {
		m[i] = o.toModel()
	}

	return m
}

// setModelRels creates and sets the relationships on *models.Item
// according to the relationships in the template. Nothing is inserted into the db
func (t ItemTemplate) setModelRels(o *models.Item) {}

// BuildSetter returns an *models.ItemSetter
// this does nothing with the relationship templates
func (o ItemTemplate) BuildSetter() *models.ItemSetter {
	m := &models.ItemSetter{}

	if o.ItemID != nil {
		m.ItemID = omit.From(o.ItemID())
	}
	if o.IsHidden != nil {
		m.IsHidden = omit.From(o.IsHidden())
	}
	if o.Categories != nil {
		m.Categories = omit.From(o.Categories())
	}
	if o.TimeStamp != nil {
		m.TimeStamp = omit.From(o.TimeStamp())
	}
	if o.Labels != nil {
		m.Labels = omit.From(o.Labels())
	}
	if o.Comment != nil {
		m.Comment = omit.From(o.Comment())
	}

	return m
}

// BuildManySetter returns an []*models.ItemSetter
// this does nothing with the relationship templates
func (o ItemTemplate) BuildManySetter(number int) []*models.ItemSetter {
	m := make([]*models.ItemSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.Item
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use ItemTemplate.Create
func (o ItemTemplate) Build() *models.Item {
	m := o.toModel()
	o.setModelRels(m)

	return m
}

// BuildMany returns an models.ItemSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use ItemTemplate.CreateMany
func (o ItemTemplate) BuildMany(number int) models.ItemSlice {
	m := make(models.ItemSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableItem(m *models.ItemSetter) {
	if m.ItemID.IsUnset() {
		m.ItemID = omit.From(random[string](nil))
	}
	if m.TimeStamp.IsUnset() {
		m.TimeStamp = omit.From(random[time.Time](nil))
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.Item
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *ItemTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.Item) (context.Context, error) {
	var err error

	return ctx, err
}

// Create builds a item and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *ItemTemplate) Create(ctx context.Context, exec bob.Executor) (*models.Item, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// create builds a item and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *ItemTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.Item, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableItem(opt)

	m, err := models.ItemsTable.Insert(ctx, exec, opt)
	if err != nil {
		return ctx, nil, err
	}
	ctx = itemCtx.WithValue(ctx, m)

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple items and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o ItemTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.ItemSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// createMany builds multiple items and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o ItemTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.ItemSlice, error) {
	var err error
	m := make(models.ItemSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// Item has methods that act as mods for the ItemTemplate
var ItemMods itemMods

type itemMods struct{}

func (m itemMods) RandomizeAllColumns(f *faker.Faker) ItemMod {
	return ItemModSlice{
		ItemMods.RandomItemID(f),
		ItemMods.RandomIsHidden(f),
		ItemMods.RandomCategories(f),
		ItemMods.RandomTimeStamp(f),
		ItemMods.RandomLabels(f),
		ItemMods.RandomComment(f),
	}
}

// Set the model columns to this value
func (m itemMods) ItemID(val string) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.ItemID = func() string { return val }
	})
}

// Set the Column from the function
func (m itemMods) ItemIDFunc(f func() string) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.ItemID = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetItemID() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.ItemID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomItemID(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.ItemID = func() string {
			return random[string](f)
		}
	})
}

func (m itemMods) ensureItemID(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.ItemID != nil {
			return
		}

		o.ItemID = func() string {
			return random[string](f)
		}
	})
}

// Set the model columns to this value
func (m itemMods) IsHidden(val bool) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.IsHidden = func() bool { return val }
	})
}

// Set the Column from the function
func (m itemMods) IsHiddenFunc(f func() bool) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.IsHidden = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetIsHidden() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.IsHidden = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomIsHidden(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.IsHidden = func() bool {
			return random[bool](f)
		}
	})
}

func (m itemMods) ensureIsHidden(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.IsHidden != nil {
			return
		}

		o.IsHidden = func() bool {
			return random[bool](f)
		}
	})
}

// Set the model columns to this value
func (m itemMods) Categories(val types.JSON[json.RawMessage]) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Categories = func() types.JSON[json.RawMessage] { return val }
	})
}

// Set the Column from the function
func (m itemMods) CategoriesFunc(f func() types.JSON[json.RawMessage]) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Categories = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetCategories() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Categories = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomCategories(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Categories = func() types.JSON[json.RawMessage] {
			return random[types.JSON[json.RawMessage]](f)
		}
	})
}

func (m itemMods) ensureCategories(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.Categories != nil {
			return
		}

		o.Categories = func() types.JSON[json.RawMessage] {
			return random[types.JSON[json.RawMessage]](f)
		}
	})
}

// Set the model columns to this value
func (m itemMods) TimeStamp(val time.Time) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.TimeStamp = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m itemMods) TimeStampFunc(f func() time.Time) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.TimeStamp = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetTimeStamp() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.TimeStamp = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomTimeStamp(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.TimeStamp = func() time.Time {
			return random[time.Time](f)
		}
	})
}

func (m itemMods) ensureTimeStamp(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.TimeStamp != nil {
			return
		}

		o.TimeStamp = func() time.Time {
			return random[time.Time](f)
		}
	})
}

// Set the model columns to this value
func (m itemMods) Labels(val types.JSON[json.RawMessage]) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Labels = func() types.JSON[json.RawMessage] { return val }
	})
}

// Set the Column from the function
func (m itemMods) LabelsFunc(f func() types.JSON[json.RawMessage]) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Labels = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetLabels() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Labels = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomLabels(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Labels = func() types.JSON[json.RawMessage] {
			return random[types.JSON[json.RawMessage]](f)
		}
	})
}

func (m itemMods) ensureLabels(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.Labels != nil {
			return
		}

		o.Labels = func() types.JSON[json.RawMessage] {
			return random[types.JSON[json.RawMessage]](f)
		}
	})
}

// Set the model columns to this value
func (m itemMods) Comment(val string) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Comment = func() string { return val }
	})
}

// Set the Column from the function
func (m itemMods) CommentFunc(f func() string) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Comment = f
	})
}

// Clear any values for the column
func (m itemMods) UnsetComment() ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Comment = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m itemMods) RandomComment(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		o.Comment = func() string {
			return random[string](f)
		}
	})
}

func (m itemMods) ensureComment(f *faker.Faker) ItemMod {
	return ItemModFunc(func(o *ItemTemplate) {
		if o.Comment != nil {
			return
		}

		o.Comment = func() string {
			return random[string](f)
		}
	})
}
